This is version **1.0.2**.

# Overview

The sequence plotter is a browser-based platform for plotting experimental sequences. By making use of the browser, we can make use of the many already existing packages for convenient rendering of plots and also intuitive interactivity. To that end we make use of
- **Dash**: Dash is a convenient Python based package utilizing **flask** for serving an app, **React** for its backend interactivity and **plotly** for utilities designed for visualizing graphs and tables. Dash also has many extensions for use together with **bootstrap**, for instance, for better styling.

## Uploading a File

The plotter requires uploading a file (in our own `.seq` format), from which it gathers all of the information about the sequence(s). This file supports multiple sequences (which can be several basic sequences in a sequence with branching or the sequences of a scan), and also supports (optionally) the inclusion of backtrace information and parameter information. After uploading a file, one can select the automatically populated sequence selector and choose a particular sequence to take a look at. Once the sequence is chosen, click "Add Figure for this Sequence" to create a figure to probe the sequence and also reveal additional sequence-specific information. Note that multiple figures can be opened for a particular sequence at your own convenience.

## Visualizing a Sequence

Once a figure is opened, the interface will create tabs which can be used to select your sequence of choice. The graph can be populated with user selected channels. The channel selector is automatically populated with all known channels and is searchable. The figure below automatically has two axes, a left and right axis. The left axis is used for all values below a million (i.e. NiDAQ, DDS/AWG amplitude channels and TTLs). The right axis is used for all values above a million (mainly frequencies). The figure can be zoomed into both using tools on the graph and the slider below the graph (for time axis zooming).

## Debugging a Sequence

Below the graph are two columns of information. The left column consists of backtrace information (i.e. which line of code is responsible for a selected point on the graph). The backtrace does not fully print but can be completely print by toggling the "Show full backtrace" slider. The right column consists of all parameter information stored in `s.C` from MATLAB in a nested tree structure. The source of `s.C` parameters can arise from definitions in your sequence or from `expConfig.m`. Those from the config are shown in blue and can be toggled with the "Show config values" slider. From the MATLAB, one can specify a reference ("default") sequence to compare this sequence to, and information from such a default sequence is stored in the `.seq` file. If the parameter values differ from the default sequence, the parameter will be shown in red and can be toggled on or off with the "Show overwritten values" slider. Lastly, values not changed from the default sequence will be in black and can be toggled on or off with the "Show default values" slider. Note that if no reference sequence is specified, there will be no overwritten values, and thus no value in red. If the reference sequence does not define a particular variable, a placeholder "?" is used for its value.

# Backend Details

## File format

We define a file format for encoding the sequence information in a flexible way. This file format is generated by MATLAB code (in the function `ExpSeq::dump_output_to_file`) and parsed with the Python code (in the function `home::process_data`). The file contains two distinct "sections", a sequence section and a backtrace section. Note that the term "sequence" here is agnostic to the basic sequence structure. In fact, as we'll see, the sequence information allows for an index that helps identify which basic sequence it might be (for convenience to the user), but these stored sequences can be basic sequences of a total sequence or different sequences altogether. The sequence section has the following format:

```
[nseqs (uint32): 4B]
    [[seq_name: null-terminated string][seq_idx (uint32): 4B]
        [nchns: 4B][[chn_name: null-terminated string]
            [npts: 4B][[[times (int64): 8B][values (double): 8B][pulse_ids (uint32): 4B]] 
            x npts]
        x nchns]
    [has_params: 1B][params: json-encoded null-terminated string] 
    x nseqs]
```

The first 4 bytes of the file will be interpreted as an unsigned 32 bit integer representing the number of sequences. The parser explicitly reads in little endian, so the writer should also write in little endian but this can be changed. Now knowing the number of sequences, the parser can interpret each sequence. The sequence is specified first with a null character terminated string (i.e. the string will be read until a null byte) and then a 4 byte sequence index, which typically represents which basic sequence is being run. The basic sequences are one-indexed where the first basic sequence is 1. Following this sequence metadata, the outputs of each channel follow. We start with a 4 byte number specifying the number of channels. Channel metadata in the form of a channel name with a null-terminated string follows. Note that the MATLAB code records the channel name in all its forms (i.e. with all user-supplied aliases) for convenience. Next follows the output of a channel. The number of output points (4 byte unsigned integer) comes first, and each output point consists of a 8 byte signed integer time, double precision (8 byte) number representing the value and a 4 byte unsigned integer `pulse_id` (zero-indexed!), which will be used for determining backtrace information. After the output, a second section of the sequence follows containing any parameter information. A 1 byte number (interpreted as a boolean, 0 is false, anything else is true) indicates whether this sequence will have parameter information. The parameter information is then json-encoded (described in more detail [below](#parameters-specification)) and stored in the file as a null-terminated string. The parser then decodes the json. 

Directly following the sequence section, the backtrace information is stored. The backtrace information is stored separately from the sequence with space considerations in mind. This is because many sequences may share the same backtrace information. For instance, this is automatically the case for several basic sequences inside of a total sequence. Many individual backtraces for the pulses can also share the same filenames or function names. With this in mind, the backtrace information has a more complex structure in an attempt to save space.

```
[has_bt_info: 1B][[bt_idx (uint32): 4B] x nseqs]
    [n_bts (uint32): 4B][
        [nfilenames (uint32): 4B]
            [[filename: null-terminated string] 
        x nfilenames]
        [nnames (uint32): 4B]
            [[name: null-terminated string]
        x nnames]
        [nobjs (uint32): 4B]
            [[nframes (uint32): 4B]
                [[filename_id (uint32): 4B][name_id (uint32): 4B][line_num (uint32): 4B] 
            x nframes] 
        x nobjs] 
    x n_bts]
```

This section starts with a 1 byte number interpreted as a boolean where a nonzero value indicates that this particular file contains backtrace information. Next comes `nseqs` number of 4 byte unsigned integers indicating which backtrace corresponds to each sequence in the previous section. These backtraces are zero-indexed, meaning that a value of zero, indicates that the sequence corresponds with the first backtrace in the subsequent list of backtraces. The number of backtraces is specified by a 4 byte unsigned integer. Each backtrace consists of three sections, a list of filenames, function names and then the actual backtrace information. The list of filenames and names follow the same formula of first specifying a 4 byte unsigned integer (the number of filenames/function names) followed by the actual list of null-terminated strings with the filenames/function names. Following these caches of names, the actual number of backtraces (called `objs`) is specified in a 4 byte unsigned integer. Each backtrace consists of a variable number of frames (a particular level in the backtrace stack), `nframes`, which is specified next. Each frame then consists of a 4 byte `filename_id` (zero-indexed!) referencing the previously provided filename list, a 4 byte `name_id` (zero-indexed!) referencing the previously provided function name list, and a 4 byte `line_num` corresponding to the line number of this frame. 

<h3 id="parameters-specification">Parameters specification</h3>

Here, we describe in more detail how parameters are specified. The parameters in the sequence are stored in a nested dictionary (nested struct in MATLAB). We take advantage of the JSON format to transfer the information from MATLAB to Python. JSON tools are widely available and supportive of nested data. Since JSON is textual, the transfer is done with a null-terminated string within our file format. For our sequence, these parameters are key-value pairs. However, we wanted to incorporate the ability to store default values and config values. One way to accomplish this is to have separate dictionaries altogether for each different type of parameter (i.e. default vs config vs ordinary), but this seems a bit wasteful of space. Thus, we store our parameters as key-value pairs where each value itself is a dictionary with some metadata. In particular, each actual value has a magic `value` field with the value of the parameter. There is a `type` field where 0 is an ordinary parameter, 1 is a config parameter, 2 is an overwritten ordinary parameter and 3 is an overwritten config parameter. Depending on the type, an `old_value` field exists and a `config_value` field exists holding the original value before overwriting and the value in the config (which might be overwritten). Note that the parameter parser in `home::dict_to_dash_elem` uses the `value` and `type` fields to determine if an actual value has been reached. Thus any field in `s.C` using both `value` and `type` will not be interpreted correctly. The MATLAB function `convert_seqval_to_string` is responsible for creating this parameter dictionary. 

## Generating the proper file in MATLAB

Here is some sample code to generate the file in MATLAB

```
%% Pick a default scan
clear s_def
bDefaultSeq = 0;
if bDefaultSeq
    params_def = struct(); % This can come from a ScanGroup.getseq for example
    params_def.debug = 1;
    s_def = NaCsSingleAtomCond(ExpSeq(params_def));
else
    s_def.C.V = struct();
end

%% Create your sequence here from a scan
% Get parameters from a representative scan
p = NaCsScans('CopropUWave2');
params = p.getseq(5);
% Enable debug features
params.debug = 1;
% Make sequence
blank_seq = ExpSeq(params, struct(s_def.C).V);
s = NaCsSingleAtomCond(blank_seq);

%% Create your sequence from statements
% params.debug = 1;
% s = ExpSeq(params);
% s.add('Dev130/0', 0);
% s.wait(10e-3);
% s.addStep(5e-3).add('Dev130/0', linearRamp(0.3, 0.7));
% 
% s.add('FPGA1/DDS1/FREQ', 50e6);
% s.wait(5e-3);
% s.addStep(50e-3).add('FPGA1/DDS1/FREQ', rampTo(70e6));

%%
pts_per_ramp = 100;
dump_filename = 'nacs_single_atom_cond.seq'; % Sequence file name. Best to end in .seq
seq_name = 'NaCsSingleAtomCond'; % Name that is displayed in the plotter
s.dump_output_to_file(pts_per_ramp,dump_filename, seq_name);
```

Note that one needs to build the reference sequence themselves and pass its parameters into the construction of the `ExpSeq` one wants to plot. The magic parameter `s.C.debug` determines whether debug information such as the backtrace and parameters are recorded in the file. Separately creating the initial `ExpSeq` before passing it onto your main sequence construction function (here: `NaCsSingleAtomCond`) ensures accurate backtrace information.

## Dash Structure

We use a multi-page dash app structure, so the main application is in the top level directory with a pages directory containing the two different pages `home.py` and `help.py`. We try to maintain modularity as much as possible. Each sequence within a file is visualized inside a `dcc.Tabs` where `dcc` stands for Dash Core Components. This visualization, as discussed above, contains a channel selector, figure, two columns of text containing backtrace and parameter information. All of these components are created in a "block" via the `home::create_new_block` function. 

Interactivity is achieved with callbacks. Since components within a certain block respond to and affect others within the same block, we make extensive use of pattern-matching callbacks in Dash to write a single callback that attaches itself to a dynamic number of components. Global information sharing within our application is handled via the `dcc.Store` component. The `seq_cache` stores all information about the `.seq` file. Each block has `chns_storage` and `seq_name` components for storing the current selected channels and sequence name for the block. Care must be taken for freeing the information (assigning the `data` inside the `dcc.Store` to `None`) when blocks are "destroyed". Blocks are id'd with the `n_clicks` attribute of the "add figure" button. For performance reasons, we use a `dcc.Patch` to update whenever possible to avoid issues with rendering.

The parameter information is currently handled using styling on `html` components. The entire nested dictionary is present but some are not displayed depending on the sliders that control the parameter information. Their `display` attribute is turned to `none` when they are hidden.